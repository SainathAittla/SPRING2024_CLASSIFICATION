def list_comp1(lst):  
    return [i for i in lst if i%3==0 or i%4==0]


def list_comp2(lst): 
    return [i*3 if i%2==0 else i*5 for i in lst]


def lambda_min(filename):
    lines = []
    with open(filename) as file:
        for line in file:
            if not line.strip():
                continue
            else:
                lines.append(str(line))
    lambda_func = lambda line: sum([int(score) for score in line.strip().split(',')[1:]])
    line_with_min_student = min(lines,key=lambda_func).strip()
    return lambda_func,line_with_min_student


def lambda_grade(filename):
    def num_to_grade(average):
        if 65<=average<70:
            return 'D'
        if 70<=average<80:
            return 'C'
        if 80<=average<90:
            return 'B'
        if 90<=average:
            return 'A'
    lines = []
    with open(filename) as file:
        for line in file:
            if not line.strip():
                continue
            else:
                lines.append(line)
    l_func = lambda line:(line.strip().split(',')[0]+': '+
                          num_to_grade(round(sum(int(score) for score in line.strip().split(',')[1:])/5)))
    student_grades = (map(l_func,lines)) 
    return l_func,student_grades

def lambda_json(filename):
    import json
    with open(filename) as infile:
        grades = json.load(infile)
    l_func = lambda a:int(a['test3'])
    output = sorted(grades,key=l_func)
    return l_func,output


def find_matching_keys(input_dict, test_value):
    output=[]
    for key in input_dict:
        if input_dict[key]==test_value:
            output.append(key)
    return output



class IteratorClass:
    def __init__(self,x,y,operator):
        if len(x)!=len(y):
            raise ValueError
        if operator not in ('add','mul','sub','div'):
            raise ValueError
        if not isinstance(x,(list,tuple)) or not isinstance(y,(list,tuple)):
            raise ValueError
        self.x=x
        self.y=y
        self.operator=operator
        self.index=0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index<len(self.x):
            if self.operator=='add':
                result = self.x[self.index]+self.y[self.index]
            if self.operator=='mul':
                result = self.x[self.index]*self.y[self.index]
            if self.operator=='sub':
                result = self.x[self.index]-self.y[self.index]
            if self.operator=='div':
                if self.y[self.index]==0:
                    raise ValueError
                else:
                    result = round(self.x[self.index]/self.y[self.index],2)
            self.index+=1
            return result
        else:
            raise StopIteration


# - ListV2
#  - __init__
#     - self.values
#  - __add__
#  - __sub__
#  - __mul__
#  - __truediv__
#  - append
#  - mean
#  - __iter__
#  - __next__
#  - __repr___
from collections import defaultdict
import copy
class ListV2:
    def __init__(self,data):
      if not isinstance(data,(list,tuple)):
        raise ValueError
      self.data = list(data)
      self.index=0
    def __iter__(self):
      return self
    def __next__(self):
      if self.index<len(self.data):
        result=self.data[self.index]
        self.index+=1
        return result
      raise StopIteration
    def __add__(self,other):
      if isinstance(other,(ListV2,list,tuple)):
        return ListV2([x+y for x,y in zip(self.data,other if isinstance(other,(list,tuple)) else other.data)])
      elif isinstance(other,(int,float)):
        return ListV2([x+other for x in self.data])
    def __sub__(self,other):
      if isinstance(other,(ListV2,list,tuple)):
        return ListV2([x-y for x,y in zip(self.data,other if isinstance(other,(list,tuple)) else other.data)])
      elif isinstance(other,(int,float)):
        return ListV2([x-other for x in self.data])
    def __mul__(self,other):
      if isinstance(other,(ListV2,list,tuple)):
        return ListV2([x*y for x,y in zip(self.data,other if isinstance(other,(list,tuple)) else other.data)])
      elif isinstance(other,(int,float)):
        return ListV2([x*other for x in self.data])
    def __truediv__(self,other):
      if isinstance(other,(ListV2,list,tuple)):
        return ListV2([round(x/y,2) for x,y in zip(self.data,other if isinstance(other,(list,tuple)) else other.data)])
      elif isinstance(other,(int,float)):
        return ListV2([round(x/other,2) for x in self.data])
    def append(self,value):
      self.data.append(value)
    def mean(self):
      return sum(self.data)/len(self.data)
    def __repr__(self):
      return str(self.data)

class Pound:
    def __init__(self,lb,oz):
      self.lb=lb
      self.oz=oz
    def __add__(self,other):
      total_oz=self.oz+other.oz
      extra_lb,oz=divmod(total_oz,16)
      return Pound(self.lb+other.lb+extra_lb,oz)
    def __sub__(self,other):
      total_self_oz = self.lb*16 + self.oz
      total_other_oz = other.lb*16 + other.oz
      if total_self_oz<total_other_oz:
        raise ValueError
      lb,oz=divmod(total_self_oz-total_other_oz,16)
      return Pound(lb,oz)
    def __repr__(self):
      return f'Pound({self.lb}, {self.oz})'
    def __str__(self):
      return f'{self.lb} lb {self.oz} oz'
