### Utility Functions
import pandas as pd
import sqlite3
from sqlite3 import Error

def create_connection(db_file, delete_db=False):
    import os
    if delete_db and os.path.exists(db_file):
        os.remove(db_file)

    conn = None
    try:
        conn = sqlite3.connect(db_file)
        conn.execute("PRAGMA foreign_keys = 1")
    except Error as e:
        print(e)

    return conn


def create_table(conn, create_table_sql, drop_table_name=None):
    
    if drop_table_name: # You can optionally pass drop_table_name to drop the table. 
        try:
            c = conn.cursor()
            c.execute("""DROP TABLE IF EXISTS %s""" % (drop_table_name))
        except Error as e:
            print(e)
    
    try:
        c = conn.cursor()
        c.execute(create_table_sql)
    except Error as e:
        print(e)
        
def execute_sql_statement(sql_statement, conn):
    cur = conn.cursor()
    cur.execute(sql_statement)

    rows = cur.fetchall()

    return rows

def step1_create_region_table(data_filename, normalized_database_filename):
    # Inputs: Name of the data and normalized database filename
    # Output: None
    conn_normalized = create_connection(normalized_database_filename)
    sql_statement='''CREATE TABLE Region (
      RegionID Integer not null primary key,
      Region Text not null
      );'''
    create_table(conn_normalized,sql_statement,drop_table_name='Region')
    unique_regions = set()
    with open(data_filename, 'r') as file:
      next(file)
      for i in file:
        i = i.strip()
        i = i.split('\t')
        area = i[4]
        unique_regions.add(area)
    unique_regions = sorted(unique_regions)
    unique_regions = [(i+1,region) for i,region in enumerate(unique_regions)]
    cursor = conn_normalized.cursor()
    sql_statement = 'Insert into Region values (?,?)'
    with conn_normalized:
       cursor.executemany(sql_statement,unique_regions)
    conn_normalized.commit()
    conn_normalized.close()


def step2_create_region_to_regionid_dictionary(normalized_database_filename):
    conn_normalized = create_connection(normalized_database_filename)
    cursor = conn_normalized.cursor()
    sql_statement = 'SELECT * from Region'
    regions = cursor.execute(sql_statement)
    map_region = {}
    for i in regions:
        map_region[i[1]]=i[0]
    conn_normalized.commit()
    conn_normalized.close()
    return map_region


def step3_create_country_table(data_filename, normalized_database_filename):
    # Inputs: Name of the data and normalized database filename
    # Output: None
    conn_normalized = create_connection(normalized_database_filename)
    sql_statement = ''' CREATE TABLE Country (
      CountryID Integer not null primary key,
      Country Text not null,
      RegionID Integer not null,
      foreign key(RegionID) References Region(RegionID)
    );'''
    create_table(conn_normalized,sql_statement,drop_table_name='Country')
    unique_country = set()
    with open(data_filename, 'r') as file:
      next(file)
      for i in file:
        i = i.strip()
        i = i.split('\t')
        country = (i[3], i[4])
        unique_country.add(country)
    unique_country = sorted(unique_country, key = lambda x: x[0])
    map_region_id = step2_create_region_to_regionid_dictionary(normalized_database_filename)
    unique_country = [(i+1, unique_country[i][0], map_region_id[unique_country[i][1]]) for i in range(len(unique_country))]
    cursor = conn_normalized.cursor()
    sql_statement = 'INSERT INTO Country values (?,?,?)'
    with conn_normalized:
       cursor.executemany(sql_statement, unique_country)
    conn_normalized.commit()
    conn_normalized.close()


def step4_create_country_to_countryid_dictionary(normalized_database_filename):
    conn_normalized = create_connection(normalized_database_filename)
    map_countries = {}
    sql_statement = 'SELECT * from Country'
    cursor = conn_normalized.cursor()
    countries = cursor.execute(sql_statement)
    for i in countries:
      map_countries[i[1]] = i[0]
    conn_normalized.commit()
    conn_normalized.close()
    return map_countries

        
def step5_create_customer_table(data_filename, normalized_database_filename):
   conn_normalized = create_connection(normalized_database_filename)
   sql_statement = '''CREATE TABLE Customer(
      CustomerID Integer not null primary key,
      FirstName Text not null,
      LastName Text not null,
      Address Text not null,
      City Text not null,
      CountryID Integer not null,
      foreign key(CountryID) references Country(CountryID)
   );'''
   create_table(conn_normalized,sql_statement,drop_table_name='Customer')
   map_countries = step4_create_country_to_countryid_dictionary(normalized_database_filename)
   customers = []
   with open(data_filename, 'r') as file:
    next(file)
    for i in file:
      i = i.strip()
      i = i.split('\t')
      first_name, last_name = i[0].split(" ", 1)
      customer = [first_name, last_name, i[1], i[2], map_countries[i[3]]]
      customers.append(customer)
   customers = sorted(customers, key = lambda x: x[0]+" "+x[1])
   customers = [(i+1, *customers[i]) for i in range(len(customers))]
   cursor = conn_normalized.cursor()
   sql_statement = 'Insert into Customer values (?,?,?,?,?,?)'
   with conn_normalized:
      cursor.executemany(sql_statement,customers)
   conn_normalized.commit()
   conn_normalized.close()

def step6_create_customer_to_customerid_dictionary(normalized_database_filename):
    conn_normalized = create_connection(normalized_database_filename)
    map_customer = {}
    sql_statement = 'Select * from Customer'
    cursor = conn_normalized.cursor()
    customer_data = cursor.execute(sql_statement)
    for i in customer_data:
      map_customer[i[1]+" "+i[2]] = i[0]
    conn_normalized.close()
    return map_customer

        
def step7_create_productcategory_table(data_filename, normalized_database_filename):
    # Inputs: Name of the data and normalized database filename
    # Output: None
    conn_normalized = create_connection(normalized_database_filename)
    sql_statement = '''Create Table  ProductCategory (
      ProductCategoryID Integer not null primary key,
      ProductCategory Text not null,
      ProductCategoryDescription Text not null
    );'''
    create_table(conn_normalized,sql_statement,drop_table_name='ProductCategory')
    prod_categories = set()
    with open(data_filename, 'r') as file:
        next(file)
        for i in file:
            i = i.strip()
            i = i.split('\t')
            prod_category = i[6].split(';')
            prod_desc = i[7].split(';')
            for j in range(len(prod_category)):
                prod_categories.add((prod_category[j],prod_desc[j]))
    prod_categories = sorted(prod_categories,key = lambda x: x[0])
    prod_categories = [(i+1, *prod_categories[i]) for i in range(len(prod_categories))]
    cursor = conn_normalized.cursor()
    sql_statement = 'Insert into ProductCategory values (?,?,?)'
    with conn_normalized:
        cursor.executemany(sql_statement, prod_categories)
    conn_normalized.commit()
    conn_normalized.close()


def step8_create_productcategory_to_productcategoryid_dictionary(normalized_database_filename):
    conn_normalized = create_connection(normalized_database_filename)
    map_category = {}
    cursor = conn_normalized.cursor()
    sql_statement = 'select * from ProductCategory'
    product_data = cursor.execute(sql_statement)
    for i in product_data:
      map_category[i[1]] = i[0]
    conn_normalized.commit()
    conn_normalized.close()
    return map_category  


def step9_create_product_table(data_filename, normalized_database_filename):
    # Inputs: Name of the data and normalized database filename
    # Output: None
    conn_normalized = create_connection(normalized_database_filename)
    sql_statement = '''CREATE Table Product (
      ProductID Integer not null primary key,
      ProductName Text not null,
      ProductUnitPrice Real not null,
      ProductCategoryID Integer not null,
      foreign key(ProductCategoryID) references ProductCategory(ProductCategoryID)
    );'''
    create_table(conn_normalized, sql_statement,drop_table_name='Product')
    map_prod_category = step8_create_productcategory_to_productcategoryid_dictionary(normalized_database_filename)
    unique_products = set()
    with open(data_filename, 'r') as file:
      next(file)
      for i in file:
        i = i.strip()
        i = i.split('\t')
        prod_name = i[5].split(';')
        prod_category = i[6].split(';')
        prod_price = i[8].split(';')
        for j in range(len(prod_name)):
          unique_products.add((prod_name[j],prod_price[j],map_prod_category[prod_category[j]]))
    unique_products = sorted(unique_products, key = lambda x: x[0])
    unique_products = [(i+1,*unique_products[i]) for i in range(len(unique_products))]
    cursor = conn_normalized.cursor()
    sql_statement = 'Insert into Product values (?,?,?,?)'
    with conn_normalized:
      cursor.executemany(sql_statement,unique_products)
    conn_normalized.commit()
    conn_normalized.close()


def step10_create_product_to_productid_dictionary(normalized_database_filename):
    conn_normalized = create_connection(normalized_database_filename)
    map_product = {}
    sql_statement = 'select * from Product'
    cursor = conn_normalized.cursor()
    product_data = cursor.execute(sql_statement)
    for i in product_data:
        map_product[i[1]] = i[0]
    conn_normalized.commit()
    conn_normalized.close()
    return map_product

def step11_create_orderdetail_table(data_filename, normalized_database_filename):
    # Inputs: Name of the data and normalized database filename
    # Output: None
    from datetime import datetime
    conn_normalized = create_connection(normalized_database_filename)
    sql_statement = '''Create Table OrderDetail (
        OrderID Integer not null primary key,
        CustomerID Integer not null,
        ProductID Integer not null,
        OrderDate Integer not null,
        QuantityOrdered Integer not null,
        foreign key(CustomerID) references Customer(CustomerID),
        foreign key(ProductID) references Product(ProductID)
    );'''
    create_table(conn_normalized,sql_statement,drop_table_name='OrderDetail')
    map_product = step10_create_product_to_productid_dictionary(normalized_database_filename)
    map_customer = step6_create_customer_to_customerid_dictionary(normalized_database_filename)
    orders = []
    with open(data_filename,'r') as file:
        next(file)
        for i in file:
            i = i.strip()
            i = i.split('\t')
            name = i[0]
            product = i[5].split(';')
            quantity = i[9].split(';')
            dates = i[10].split(';')
            for j in range(len(product)):
                date = datetime.strptime(dates[j], '%Y%m%d').strftime('%Y-%m-%d')
                orders.append((map_customer[name],map_product[product[j]],date,int(quantity[j])))
    orders = sorted(orders, key = lambda x: x[0])
    orders = [(i+1,*orders[i]) for i in range(len(orders))]
    sql_statement = 'Insert into OrderDetail values (?,?,?,?,?)'
    cursor = conn_normalized.cursor()
    with conn_normalized:
        cursor.executemany(sql_statement,orders)
    conn_normalized.commit()
    conn_normalized.close()


def ex1(conn, CustomerName):
    
    # Simply, you are fetching all the rows for a given CustomerName. 
    # Write an SQL statement that SELECTs From the OrderDetail table and joins with the Customer and Product table.
    # Pull out the following columns. 
    # Name -- concatenation of FirstName and LastName
    # ProductName
    # OrderDate
    # ProductUnitPrice
    # QuantityOrdered
    # Total -- which is calculated from multiplying ProductUnitPrice with QuantityOrdered -- round to two decimal places
    # HINT: USE customer_to_customerid_dict to map customer name to customer id and then use where clause with CustomerID
    sql_statement = f"""
    select
    c.FirstName ||' ' || c.LastName as Name,
    p.ProductName,
    o.OrderDate,
    p.ProductUnitPrice,
    o.QuantityOrdered,
    round(p.ProductUnitPrice * o.QuantityOrdered, 2) AS Total
    from
    OrderDetail o
    join
    Customer c ON o.CustomerID = c.CustomerID
    join
    Product p ON o.ProductID = p.ProductID
    where
    c.CustomerID = (select CustomerID from Customer where FirstName || ' ' || LastName = '{CustomerName}')
    """ 
    return sql_statement

def ex2(conn, CustomerName):
    
    # Simply, you are summing the total for a given CustomerName. 
    # Write an SQL statement that SELECTs From the OrderDetail table and joins with the Customer and Product table.
    # Pull out the following columns. 
    # Name -- concatenation of FirstName and LastName
    # Total -- which is calculated from multiplying ProductUnitPrice with QuantityOrdered -- sum first and then round to two decimal places
    # HINT: USE customer_to_customerid_dict to map customer name to customer id and then use where clause with CustomerID
    
    sql_statement = f"""
    select
    c.FirstName || ' ' || c.LastName as Name,
    round(sum(p.ProductUnitPrice * o.QuantityOrdered), 2) AS Total
    from
    OrderDetail o
    join
    Customer c ON o.CustomerID = c.CustomerID
    join
    Product p ON o.ProductID = p.ProductID
    where
    c.CustomerID = (SELECT CustomerID FROM Customer WHERE FirstName || ' ' || LastName = '{CustomerName}')
    group by
    c.CustomerID
    """
    return sql_statement

def ex3(conn):
    # Simply, find the total for all the customers
    # Write an SQL statement that SELECTs From the OrderDetail table and joins with the Customer and Product table.
    # Pull out the following columns. 
    # Name -- concatenation of FirstName and LastName
    # Total -- which is calculated from multiplying ProductUnitPrice with QuantityOrdered -- sum first and then round to two decimal places
    # ORDER BY Total Descending 
    
    sql_statement = """
    select
    c.FirstName || ' ' || c.LastName as Name,
    round(sum(p.ProductUnitPrice * o.QuantityOrdered), 2) as Total
    from
    OrderDetail o
    join
    Customer c ON o.CustomerID = c.CustomerID
    join
    Product p ON o.ProductID = p.ProductID
    group by
    c.CustomerID
    order by
    Total desc
    """
    return sql_statement

def ex4(conn):
    # Simply, find the total for all the region
    # Write an SQL statement that SELECTs From the OrderDetail table and joins with the Customer, Product, Country, and 
    # Region tables.
    # Pull out the following columns. 
    # Region
    # Total -- which is calculated from multiplying ProductUnitPrice with QuantityOrdered -- sum first and then round to two decimal places
    # ORDER BY Total Descending 
    
    sql_statement = """
    select
    r.Region,
    round(sum(p.ProductUnitPrice * o.QuantityOrdered), 2) as Total
    from
    OrderDetail o
    join
    Customer c ON o.CustomerID = c.CustomerID
    join
    Product p ON o.ProductID = p.ProductID
    join
    Country co ON c.CountryID = co.CountryID
    join
    Region r ON co.RegionID = r.RegionID
    group by
    r.RegionID
    order by
    Total desc;
    """
    return sql_statement

def ex5(conn):
    # Simply, find the total for all the countries
    # Write an SQL statement that SELECTs From the OrderDetail table and joins with the Customer, Product, and Country table.
    # Pull out the following columns. 
    # Country
    # Total -- which is calculated from multiplying ProductUnitPrice with QuantityOrdered -- sum first and then round
    # ORDER BY Total Descending 

    sql_statement = """
    select
    co.Country,
    round(sum(p.ProductUnitPrice * o.QuantityOrdered)) as Total
    from
    OrderDetail o
    join
    Customer c ON o.CustomerID = c.CustomerID
    join
    Product p ON o.ProductID = p.ProductID
    join
    Country co ON c.CountryID = co.CountryID
    group by
    co.CountryID
    order by
    Total desc;
    """
    return sql_statement


def ex6(conn):
    # Rank the countries within a region based on order total
    # Output Columns: Region, Country, CountryTotal, TotalRank
    # Hint: Round the the total
    # Hint: Sort ASC by Region

    sql_statement = """
    select
    r.Region,
    co.Country,
    round(sum(p.ProductUnitPrice * o.QuantityOrdered)) as CountryTotal,
    rank() over (partition by r.RegionID order by sum(p.ProductUnitPrice * o.QuantityOrdered) DESC) AS TotalRank
    from
    OrderDetail o
    join
    Customer c on o.CustomerID = c.CustomerID
    join
    Product p on o.ProductID = p.ProductID
    join
    Country co on c.CountryID = co.CountryID
    join
    Region r on co.RegionID = r.RegionID
    group by
    r.RegionID, co.CountryID
    order by
    r.RegionID asc, CountryTotal desc
    """

# WRITE YOUR CODE HERE
    df = pd.read_sql_query(sql_statement, conn)
    return sql_statement



def ex7(conn):
    # Rank the countries within a region based on order total, BUT only select the TOP country, meaning rank = 1!
    # Output Columns: Region, Country, Total, TotalRank
    # Hint: Round the the total
    # Hint: Sort ASC by Region
    # HINT: Use "WITH"

    sql_statement = """
    with RankedCountries as (
    select
        r.Region,
        co.Country,
        round(sum(p.ProductUnitPrice * o.QuantityOrdered)) as CountryTotal,
        rank() over (partition by r.RegionID order by sum(p.ProductUnitPrice * o.QuantityOrdered) desc) as CountryRegionalRank
    from
        OrderDetail o
    join
        Customer c on o.CustomerID = c.CustomerID
    join
        Product p on o.ProductID = p.ProductID
    join
        Country co on c.CountryID = co.CountryID
    join
        Region r on co.RegionID = r.RegionID
    group by
        r.RegionID, co.CountryID
    )

    select
    Region,
    Country,
    CountryTotal,
    CountryRegionalRank
    from
    RankedCountries
    where
    CountryRegionalRank = 1
    order by
    Region asc;

    """
# WRITE YOUR CODE HERE
    return sql_statement

def ex8(conn):
    # Sum customer sales by Quarter and year
    # Output Columns: Quarter,Year,CustomerID,Total
    # HINT: Use "WITH"
    # Hint: Round the the total
    # HINT: YOU MUST CAST YEAR TO TYPE INTEGER!!!!

    sql_statement = """
    with CustomerSales AS (
    select
        c.CustomerID,
        strftime('%Y', o.OrderDate) as Year,
        cast(strftime('%Y', o.OrderDate) as Integer) as YearInt,
        strftime('%m', o.OrderDate) as Month,
        case
            WHEN strftime('%m', o.OrderDate) BETWEEN '01' AND '03' THEN 'Q1'
            WHEN strftime('%m', o.OrderDate) BETWEEN '04' AND '06' THEN 'Q2'
            WHEN strftime('%m', o.OrderDate) BETWEEN '07' AND '09' THEN 'Q3'
            WHEN strftime('%m', o.OrderDate) BETWEEN '10' AND '12' THEN 'Q4'
        end as Quarter,
        p.ProductUnitPrice * o.QuantityOrdered AS SaleAmount
    from
        OrderDetail o
    join
        Customer c ON o.CustomerID = c.CustomerID
    join
        Product p ON o.ProductID = p.ProductID
    )

    select
    Quarter,
    YearInt AS Year,  -- Use the casted year for output
    CustomerID,
    round(sum(SaleAmount)) AS Total
    from
    CustomerSales
    group by
    Quarter, YearInt, CustomerID
    order by
    YearInt, Quarter, CustomerID;
    """
    return sql_statement

def ex9(conn):
    # Rank the customer sales by Quarter and year, but only select the top 5 customers!
    # Output Columns: Quarter, Year, CustomerID, Total
    # HINT: Use "WITH"
    # Hint: Round the the total
    # HINT: YOU MUST CAST YEAR TO TYPE INTEGER!!!!
    # HINT: You can have multiple CTE tables;
    # WITH table1 AS (), table2 AS ()

    sql_statement = """
    with CustomerSales as (
    select
        c.CustomerID,
        cast(strftime('%Y', o.OrderDate) as INTEGER) as Year,
        case
            WHEN strftime('%m', o.OrderDate) BETWEEN '01' AND '03' THEN 'Q1'
            WHEN strftime('%m', o.OrderDate) BETWEEN '04' AND '06' THEN 'Q2'
            WHEN strftime('%m', o.OrderDate) BETWEEN '07' AND '09' THEN 'Q3'
            WHEN strftime('%m', o.OrderDate) BETWEEN '10' AND '12' THEN 'Q4'
        end as Quarter,
        round(sum(p.ProductUnitPrice * o.QuantityOrdered)) as Total
    from
        OrderDetail o
    join
        Customer c on o.CustomerID = c.CustomerID
    join
        Product p on o.ProductID = p.ProductID
    group by
        c.CustomerID, Year, Quarter
    ),
    SalesRanking as (
    select
        Quarter,
        Year,
        CustomerID,
        Total,
        rank() over (partition by Quarter, Year order by Total desc) as CustomerRank
    from
        CustomerSales
    )

    select
    Quarter,
    Year,
    CustomerID,
    Total,
	  CustomerRank
    from
    SalesRanking
    where
    CustomerRank <= 5
    order by
    Year, Quarter, CustomerRank;
    """

    return sql_statement

def ex10(conn):
    # Rank the monthy sales
    # Output Columns: Quarter, Year, CustomerID, Total
    # HINT: Use "WITH"
    # Hint: Round the the total

    sql_statement = """
    WITH Output AS (
    SELECT  CASE
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (1) THEN 'January'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (2) THEN 'February'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (3) THEN 'March'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (4) THEN 'April'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (5) THEN 'May'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (6) THEN 'June'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (7) THEN 'July'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (8) THEN 'August'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (9) THEN 'September'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (10) THEN 'October'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (11) THEN 'November'
    WHEN cast(strftime('%m',OrderDate) AS INTEGER) IN (12) THEN 'December'
    END AS Month,
    SUM(round(ProductUnitPrice * QuantityOrdered)) AS Total, RANK() OVER(PARTITION BY cast(strftime('%m',OrderDate) AS INTEGER) ORDER BY SUM(round(ProductUnitPrice * QuantityOrdered)) DESC) AS Rank, 
    cast(strftime('%Y',OrderDate) AS INTEGER) AS Year,OrderDate, Customer.CustomerID AS CustomerID, ProductUnitPrice, QuantityOrdered
    FROM OrderDetail 
    JOIN Customer ON Customer.CustomerID = OrderDetail.CustomerID
    JOIN Product ON Product.ProductID = OrderDetail.ProductID
    GROUP BY cast(strftime('%m',OrderDate) AS INTEGER)
    ORDER BY SUM(round(ProductUnitPrice * QuantityOrdered))
    )
    SELECT Month,Total,RANK() OVER(ORDER BY Total DESC) AS TotalRank
    FROM Output;
    """

    return sql_statement

def ex11(conn):
    # Find the MaxDaysWithoutOrder for each customer 
    # Output Columns: 
    # CustomerID,
    # FirstName,
    # LastName,
    # Country,
    # OrderDate, 
    # PreviousOrderDate,
    # MaxDaysWithoutOrder
    # order by MaxDaysWithoutOrder desc
    # HINT: Use "WITH"; I created two CTE tables
    # HINT: Use Lag
    sql_statement = """
    WITH OrderDetails AS (
    SELECT
        Customer.CustomerID,
        Customer.FirstName,
        Customer.LastName,
        Country.Country,
        OrderDetail.OrderDate,
        LAG(OrderDetail.OrderDate) OVER (
            PARTITION BY Customer.CustomerID 
            ORDER BY OrderDetail.OrderDate
        ) AS PreviousOrderDate
    FROM
        Customer
    JOIN
        OrderDetail ON Customer.CustomerID = OrderDetail.CustomerID
    JOIN
        Country ON Customer.CountryID = Country.CountryID
),
Gaps AS (
    SELECT
        CustomerID,
        FirstName,
        LastName,
        Country,
        OrderDate,
        PreviousOrderDate,
        julianday(OrderDate) - julianday(PreviousOrderDate) AS DaysWithoutOrder
    FROM
        OrderDetails
    WHERE
        PreviousOrderDate IS NOT NULL
),
MaxGaps AS (
    SELECT
        CustomerID,
        FirstName,
        LastName,
        Country,
        MAX(DaysWithoutOrder) AS MaxDaysWithoutOrder
    FROM
        Gaps
    GROUP BY
        CustomerID, FirstName, LastName
),
FinalTable AS (
    SELECT
        g.CustomerID,
        g.FirstName,
        g.LastName,
        g.Country,
        g.OrderDate,
        g.PreviousOrderDate,
        m.MaxDaysWithoutOrder
    FROM
        Gaps g
    JOIN
        MaxGaps m ON g.CustomerID = m.CustomerID AND g.DaysWithoutOrder = m.MaxDaysWithoutOrder
    WHERE
        (g.FirstName, g.LastName, g.DaysWithoutOrder) IN (
            SELECT
                FirstName,
                LastName,
                MAX(DaysWithoutOrder)
            FROM
                Gaps
            GROUP BY
                FirstName, LastName
        )
),
Deduplicated AS (
    SELECT
        CustomerID,
        FirstName,
        LastName,
        Country,
        OrderDate,
        PreviousOrderDate,
        MaxDaysWithoutOrder,
        ROW_NUMBER() OVER (
            PARTITION BY FirstName, LastName 
            ORDER BY MaxDaysWithoutOrder DESC, OrderDate ASC, PreviousOrderDate ASC
        ) AS rn
    FROM
        FinalTable
)
SELECT
    CustomerID,
    FirstName,
    LastName,
    Country,
    OrderDate,
    PreviousOrderDate,
    MaxDaysWithoutOrder
FROM
    Deduplicated
WHERE rn = 1
ORDER BY MaxDaysWithoutOrder DESC, CustomerID DESC;

    """
    return sql_statement